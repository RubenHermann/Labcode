---
title: "Chapter 6"
author: "Ruben J, Hermann"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(Hmsc)
library(ape)
library(MASS)
library(tidyverse)
```


###  6.6.1 Simulating Species Niches
first generating niche variation for species communities depicted in Fig 6.5
scirpt uses rcoal function from ape package to construct random phylogeny of 100 species and vcv function of ape package to turn phylogenetic tre into a phylogenetic correlation matrix **C**
```{r}
ns = 100
phy = rcoal(n = ns, tip.label = sprintf('sp_%.3d',1:ns), br = 'coalescent')
C = vcv(phy, model = 'Brownian', corr = TRUE)
plot(phy)
```

phylogenetic tree cna be visualized with ``plot(phy)``

For Community A traits are sampled independently from standard normal distribution
Community B traits are sampled from multivariate normal distribution, where variance-covariance matrix = phylogenetic matrix **C**
```{r}
Tr.A = cbind(rep(1,ns), rnorm(ns))
Tr.B = cbind(rep(1,ns), mvrnorm(n = 1,mu = rep(0, ns), Sigma = C))
rownames(Tr.A) <- phy$tip.label
```

For both intercept is added to the trait matrix (so Eq. 6.3 can be applied); then we defone $\Gamma$ matrix, which describes the link between species traits and niches and use matrix product ``%*%`` to compute expected values of species niches (according to Eq 6.3)
```{r}
gamma = cbind(c(-2,2), c(-1,1))
mu.A = gamma %*% t(Tr.A)
mu.B = gamma %*% t(Tr.B)
```

Next applying Eq 6.7 generating species niches --> Community A residual variation s phylogenetically fully structured & Community B residual variation is fully independent among species
```{r}
V2 = diag(2)
beta.A = matrix(mvrnorm(n = 1, mu = as.vector(mu.A),
Sigma = kronecker(C, V2)), ncol = ns)
beta.B = matrix(mvrnorm(n = 1, mu = as.vector(mu.B),
Sigma = kronecker(diag(ns), V2)), ncol = ns)
```

### 6.6.2 Simulating Species Data
We assume that our species communities are embedded within the same environmental context that we used to illustrate the univariate models in Section 5.6. Thus, we consider a single environmental covariate $x$, and use the standard normal distribution to simulate variation in $x$ over $n$= 50 sampling units.
```{r}
n = 50
X = cbind(rep(1, n), rnorm(n))
```

we have also included the intercept to the **X** matrix so that we can compute the linear predictor conveniently in a matrix notation
```{r}
L.A = X %*% beta.A
L.B = X %*% beta.B
```

What remains is to convert the linear predictors into community data (matrix **Y**). This example is about occurrence data, thus we convert the linear predictors to presences and absences with the help of the probit model.
```{r}
Y.A = 1*((L.A + matrix(rnorm(n*ns), ncol = ns)) > 0)
Y.B = 1*((L.B + matrix(rnorm(n*ns), ncol = ns)) > 0)
```


### 6.6.3 Exploring the Raw Data
Before fitting data it is always good to explore the raw data
a. Since our data are about species occurrences, we may wish to look at variation in species richness and in species prevalences. The species richness for each sampling unit can be computed as the row sums of the community data matrix **Y**, whereas species prevalences are given by the column means.
```{r}
S.A = rowSums(Y.A)
P.A = colMeans(Y.A)
S.B = rowSums(Y.B)
P.B = colMeans(Y.B)

hist(S.A,ylab="Frequency",xlab="Species richness (S.A)",main="Commmunity A")
hist(P.A,ylab="Frequency",xlab="Species prevalence (P.A)",main="Commmunity A")
hist(S.B,ylab="Frequency",xlab="Species richness (S.B)",main="Commmunity B")
hist(P.B,ylab="Frequency",xlab="Species prevalence (P.B)",main="Commmunity B")

plot(X[,2],S.A,ylab="Species richness (S.A)",xlab="Covariate x",main="Community A")
plot(X[,2],S.B,ylab="Species richness (S.B)",xlab="Covariate x",main="Community B")
```


### 6.6.4 Fitting an HMSC Model for the Community A with Phylogenetically Structured Species Niches
First need to format the data to make it suitable for HMSC
```{r}
community = "A"
Y = switch(community, "A" = Y.A, "B" = Y.B)
colnames(Y) = phy$tip.label
Tr = switch(community, "A" = Tr.A, "B" = Tr.B)
TrData = data.frame(trait = Tr [,2])
XData = data.frame(x = X [,2])
```

In the script above, we introduced the variable community, which can be set as ‘A’ or ‘B’, depending on which community dataset we wish to analyse. By doing so, we can easily replicate the analyses for Community B after first running them for Community A. From now on, we will show the results for Community A, and return to Community B in the end of the section.

We have named the species according to the tip labels of the phylogeny, so that the species in the phylogenetic tree correspond to those in the **Y** matrix. We have placed the trait data into the dataframe TrData and the environmental data into the dataframe XData. Note that in both of these two dataframes we have excluded the intercept, as it is internally added by Hmsc

We model species occurrences as a linear function of the environmental variable $x$ (called $x$ in the dataframe XData), and species niches as a linear function of the trait covariate $t_{j2}$ (called trait in the dataframe TrData). Since our data are on species occurrences, we fit a probit model.
```{r}
m = Hmsc(Y = Y, XData = XData, XFormula = ~x, TrData = TrData,
TrFormula = ~trait, phyloTree = phy, distr = "probit")
```

Model fitting
```{r}
nChains = 2
thin = 5
samples = 1000
transient = 500*thin
verbose = 500*thin
```
```{r}
verbose = 0
m = sampleMcmc(m, thin = thin, samples = samples,
transient = transient, nChains = nChains, verbose = verbose)
```

When performing the model fitting, we selected the sampling parameters (choices not shown, in order to keep our treatment compact) so that they lead to satisfactory MCMC convergence, as shown below for the $\rho$ parameter and in Figure 6.8 for the $\beta$ and $\gamma$ parameters.
```{r}
mpost = convertToCodaObject(m)
effectiveSize(mpost$Rho)
## 		var1
## 233.795 
gelman.diag(mpost$Rho,multivariate=FALSE,
autoburnin=FALSE)$psrf
## 				Point est. Upper C.I.
## [1,]  0.9998751  0.9998942

hist(effectiveSize(mpost$Beta),ylab="Frequency",xlab=~paste("Effective sample size (parameter ",beta,")"),main=NULL)
hist(gelman.diag(mpost$Beta, multivariate=FALSE)$psrf,ylab="Frequency",xlab=~paste("Potential scale reduction factor (parameter ",beta,")"),main=NULL)

hist(effectiveSize(mpost$Gamma),ylab="Frequency",xlab=~paste("Effective sample size (parameter ",gamma,")"),main=NULL)
hist(gelman.diag(mpost$Gamma, multivariate=FALSE)$psrf,ylab="Frequency",xlab=~paste("Potential scale reduction factor (parameter ",gamma,")"),main=NULL)
```
### 6.6.5 Explanatory and Predictive Powers of the HMSC Model

Next evaluating explanatory and predictive powers
```{r}
preds = computePredictedValues(m)
MF = evaluateModelFit(hM = m, predY = preds)

partition = createPartition(m, nfolds = 2)
preds = computePredictedValues(m, partition = partition)
MFCV = evaluateModelFit(hM = m, predY = preds)

plot(MF$AUC,MF$TjurR2,ylab=" Explanatory power (MF$TjurR2)",xlab="Explanatory power (MF$AUC)",main=paste("AUC = ",round(mean(MF$AUC,na.rm=T),digit=2),", TjurR^2  = ",round(mean(MF$TjurR2,na.rm=T),digit=2),""),ylim = c(0,1),xlim = c(0,1));abline(coef=c(0,1))

plot(MF$AUC,MF$TjurR2,ylab=" Predictive power (MFCV$TjurR2)",xlab="Predictive power (MFCV$AUC)",main=paste("AUC = ",round(mean(MFCV$AUC,na.rm=T),digit=2),", Tjur R^2 = ",round(mean(MFCV$TjurR2 ,na.rm=T),digit=2),""),ylim = c(0,1),xlim = c(0,1));abline(coef=c(0,1))
```
there are now multiple species, and thus model fit is assessed separately for each of them
we show model fit in terms of both AUC and Tjur *R^2^* to make the point that these two measures are correlated but their absolute values differ


### 6.6.6 Examining Parameter Estimates
the main focus is on modelling species niches ($\beta$ parameters) as a function of species traits (matrx **T** and regression parameter $\rho$) and phylogeny (matrix **C** and phylogenetic signal parameter $\rho$)
exploring these links with ploting parameters estimated for the simulated species community --> first apply function plotBeta to visualize estimate niches
```{r}
postBeta = getPostEstimate(m, parName = "Beta")
plotBeta(m, post = postBeta, param = "Sign", plotTree = TRUE,
supportLevel = 0.95, split = 0.4, spNamesNumbers = c(F,F))
```


next function plotGamma to visualize how species niches are estimated to depend on species traits
```{r}
postGamma = getPostEstimate(m, parName = "Gamma")
plotGamma(m, post = postGamma, param = "Sign",
supportLevel = 0.95)
```
